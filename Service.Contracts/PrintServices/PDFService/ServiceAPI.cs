///* 
// * NOTE: This code was moved to the external library PDFLib (implemented by Smartek-Soft)
// * */
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;
//using System.Threading.Tasks;

//namespace Service.Contracts.PrintServices.PDFAPI
//{
//	// Top level API contract, we still need to define if the implementation will be a Singleton or Transient object.
//	public interface IPDFDocumentCreator
//	{
//		/// <summary>
//		/// Creates a PDF document using the supplied document model.
//		/// </summary>
//		/// <param name="model">The document model describes every element and label that should be rendered in the doucment.</param>
//		/// <returns>
//		/// A single task that can be awaited by the caller, which should resolve once the document is complete or an exception
//		/// is thrown.
//		/// </returns>
//		/// <remarks>
//		/// IMPORTANT: In case of exception, the exception should not be captured or overwritten by the library code, the exception
//		/// should be allowed to flow back to the caller, we will perform any exception handlig necesary (and any logging too).
//		/// However, internally the library can keep its own log file (indeendent of our service logging), this in order to ease
//		/// troubleshooting.
//		/// </remarks>
//		Task CreateDocument(PDFDocumentModel model);

//		Task PrintDocument(string pdfFilePath, string printerName, int pageNumber);
//	}


//	public interface IPDFServiceX
//	{
//		bool CreateDocument(PDFDocumentModel model);
//	}

//	public class PDFServiceXImpl : IPDFServiceX
//	{
//		public bool CreateDocument(PDFDocumentModel model)
//		{
//			return true;
//		}
//	}

//	// NOTE: Most units of measurement in the document model are in millimeters (unless another unit is specified)

//	public class PDFDocumentModel
//	{
//		/// <summary>
//		/// The output file that should be generated by the CreateDocument method. NOTE: If the file exists, it
//		/// should be overwritten. Cannot be null, must be a valid file path.
//		/// </summary>
//		public string OutputFile { get; set; }

//		/// <summary>
//		/// Specifies the path of the log file that should be created by the library, this should be a plain text
//		/// file that can be used to ease troubleshooting in case of an error.
//		/// </summary>
//		public string LogFile { get; set; }

//		/// <summary>
//		/// Determines how many threads/processes will be spawned internally in order to speed up the document
//		/// creation process. Normally this will be equal to the number of cores available in the system.
//		/// Cannot be less than 1.
//		/// </summary>
//		public int DegreeOfParalelism { get; set; }

//		/// <summary>
//		/// Output document resolution in DPI (default 200dpi)
//		/// </summary>
//		public int Resolution { get; set; } = 200;

//		/// <summary>
//		/// Paper size, specifies the paper size in millimeters. NOTE: Element coordinates will be supplied taking
//		/// into account the specified paper size.
//		/// </summary>
//		public PDFSize PaperSize { get; set; }

//		/// <summary>
//		/// List of fonts to be used in the document, these will be referenced from the elements. Can be null or empty.
//		/// </summary>
//		public List<PDFFont> Fonts { get; set; }

//		/// <summary>
//		/// Indicates if the labels used to generate previews will use a database (supplied in a .mdb file) or 
//		/// variables (supplied in json array of objects).
//		/// </summary>
//		/// <remarks>
//		/// All labels mixed in a document will use the same configuration for its data source, that is, it will
//		/// not be possible to mix labels using a database with labels using variables.
//		/// </remarks>
//		public DataSourceType DataSourceType { get; set; }

//		/// <summary>
//		/// To be used only if DataSourceType is set to Database, this contains the full path to the .mdb file used to
//		/// feed data into the labels.
//		/// </summary>
//		public string AccessFile { get; set; }

//		/// <summary>
//		/// To be used only if DataSourceType is set to Variables, this contains a json array, where each element of the
//		/// array contains an object whose properties match the variables found in the label.
//		/// </summary>
//		public string JsonData { get; set; }

//		/// <summary>
//		/// Set of label previews that will be generated by the library and which will be referenced from the
//		/// PDFLabelPreviewElements laid out in the document. Can be null or empty.
//		/// </summary>
//		public List<LabelPreview> Previews { get; set; }

//		/// <summary>
//		/// Set of "fixed" elements that should be included on each created page, these will always be the same on
//		/// all pages. If possible, these elements should be optimized to reduce PDF size. Can be null or empty.
//		/// </summary>
//		/// <remarks>
//		/// The content of each page should be the sum of the FixedElements defined here, plus the elements defined
//		/// specifically in each individual page. NOTE: The elements specific to each page are defined below using
//		/// the Pages property.
//		/// </remarks>
//		public List<PDFElement> FixedElements { get; set; }

//		/// <summary>
//		/// Information that should be used to guide the creation of each page of the document. Cannot be null as the document
//		/// should at least contain one page.
//		/// </summary>
//		public List<PDFPageInfo> Pages { get; set; }
//	}


//	/// <summary>
//	/// Defines all the information needed to generate a label preview. Label previews are then referenced from the 
//	/// PDFElements that will be laid out in the document.
//	/// 
//	/// Notice that we have two scenarios that should be taken into account:
//	/// 
//	/// > Non-serialized labels. In this scenario, a single preview can be reused many times across one or more pages.
//	///   This is because the label does not contain any elements that make each printed unit unique.
//	///   
//	/// > Serialized labels. In this scenario, each printed unit will have at least one piece of data that makes each
//	///   unique (for instance a QR code, or a serial number that is visible in the label itself).
//	/// 
//	/// Example 1: We have a non-serialized label, the order includes 5 different EANs (one for each size/color)
//	/// and we should produce 200 of each for a total of 1000 labels. Also, we can layout 6 labels per page. In this
//	/// example, we will only ask for 5 previews, and in the PDF document model we will layout the 1000 units using
//	/// 167 pages (each element in the document will reference one of the 5 generated previews).
//	/// 
//	/// Example 2: We have the same order as in the previous example, but the label in this case is serialized, in this
//	/// scenario we will ask for 1000 previews, and each element in the document will reference one of these previews.
//	/// </summary>
//	public class LabelPreview
//	{
//		/// <summary>
//		/// ID used to reference this preview from within the document
//		/// </summary>
//		public int PreviewID { get; set; }

//		/// <summary>
//		/// Full path to the nice label file (either .nlbl or .lbl). Must be a valid path to a nice label file.
//		/// </summary>
//		public string LabelFile { get; set; }

//		/// <summary>
//		/// Determines if the label preview is serialized (true) or not (false). Serialized previews will only be referenced once
//		/// while non-serialized previews can be referenced multiple times from different LabelPreviewElements.
//		/// </summary>
//		public bool Serialized { get; set; }

//		/// <summary>
//		/// The ID of the record from the database that should be used to feed data into the label, or when the label
//		/// is feed using variables, the index within the json array that corresponds to the element that should be
//		/// used to initialize the label variables.
//		/// </summary>
//		/// <remarks>
//		/// NOTE: Even if the document is composed using different labels, they all will feed from the same data
//		/// source.
//		/// </remarks>
//		public int RowID { get; set; }

//		/// <summary>
//		/// Determines which sides of the label should be previewed (either front, back, or both). If label does not have two
//		/// sides, only front will be valid.
//		/// </summary>
//		public LabelSide Side { get; set; }

//		/// <summary>
//		/// Defines if the preview of the label should be rotated. Can be set to none, 90, 180 or 270 degrees.
//		/// </summary>
//		public LabelRotation Rotation { get; set; }
//	}


//	public class PDFPageInfo
//	{

//		/// <summary>
//		/// Set of "variable" elements that should be rendered in this page. These will have different
//		/// values on each page or might only exist in this page, therefore, there is no way to optimize
//		/// them. Cannot be null as the page should contain at least one element.
//		/// </summary>
//		public List<PDFElement> Elements { get; set; }
//	}



//	public enum DataSourceType
//	{
//		Database,       // label is bound to an access database
//		Variables       // label uses variables instead of a database
//	}


//	public enum PDFElementType
//	{
//		Line,
//		Rectangle,
//		CutGuides,
//		Image,
//		Text,
//		Barcode, // NOTE: If problematic, we should be able to replace this by a LablePreview where the label will contain the desired barcode
//		LabelPreview
//	}


//	public enum PDFElementAlignment
//	{
//		LeftTop,
//		CenterTop,
//		RightTop,
//		LeftMiddle,
//		CenterMiddle,
//		RightMiddle,
//		LeftBottom,
//		CenterBottom,
//		RightBottom,
//		BestFit // applicable only to images
//	}


//	public class PDFElement
//	{
//		public virtual PDFElementType ElementType { get; }
//	}


//	public class PDFLineElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.Line; }

//		/// <summary>
//		/// Left side x coordinate in millimeters
//		/// </summary>
//		public double X1 { get; set; }

//		/// <summary>
//		/// Top side y coordinate in millimeters
//		/// </summary>
//		public double Y1 { get; set; }

//		/// <summary>
//		/// Right side x coordinate in millimeters
//		/// </summary>
//		public double X2 { get; set; }

//		/// <summary>
//		/// Bottom side y coordinate in millimeters
//		/// </summary>
//		public double Y2 { get; set; }

//		/// <summary>
//		/// Color of the stroke (default to black)
//		/// </summary>
//		public ARGBColor Color { get; set; } = ARGBColor.Black;

//		/// <summary>
//		/// Thickness of the stroke in millimeters
//		/// </summary>
//		public double Thickness { get; set; } = 0.5;

//		/// <summary>
//		/// Style of the line
//		/// </summary>
//		public LineStyle LineStyle { get; set; } = LineStyle.Solid;
//	}


//	public enum LineStyle
//	{
//		Solid,
//		Dot,
//		Dash
//	}


//	public class PDFRectangleElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.Rectangle; }

//		/// <summary>
//		/// Area where the rectangle should be laid out within the current page
//		/// </summary>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// Color of the stroke (default to black)
//		/// </summary>
//		public ARGBColor Color { get; set; } = ARGBColor.Black;

//		/// <summary>
//		/// Color of the inner area of the rectangle, default to transparent.
//		/// </summary>
//		/// <remarks>
//		/// If the Alpha component of the color is 0, then no background color
//		/// should be rendered.
//		/// </remarks>
//		public ARGBColor BackColor { get; set; } = ARGBColor.None;

//		/// <summary>
//		/// Thickness of the stroke in millimeters
//		/// </summary>
//		public double Thickness { get; set; } = 0.5;

//		/// <summary>
//		/// Style of the rectangle lines
//		/// </summary>
//		public LineStyle LineStyle { get; set; } = LineStyle.Solid;
//	}


//	public class PDFCutGuidesElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.CutGuides; }

//		/// <summary>
//		/// Area where the rectangle should be laid out within the current page
//		/// </summary>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// Color of the stroke (default to black)
//		/// </summary>
//		public ARGBColor Color { get; set; } = ARGBColor.Black;

//		/// <summary>
//		/// Thickness of the stroke in millimeters
//		/// </summary>
//		public double Thickness { get; set; } = 0.5;

//		/// <summary>
//		/// Length of the lines that make up the cut guides in millimeters
//		/// </summary>
//		public double Length = 5.0;
//	}


//	public class PDFImageElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.Image; }

//		/// <summary>
//		/// Path to the image that should be included as a fixed element in the document. Should always be a valid file path.
//		/// Expected formats include: jpg, gif, png, tiff (but the more that can be supported the better). PDF document should
//		/// use the highest possible image quality.
//		/// </summary>
//		/// <remarks>
//		/// Documents tend to reuse the same images over and over, so image elements sharing the same ImagePath should be optimized.
//		/// </remarks>
//		public string ImagePath { get; set; }

//		/// <summary>
//		/// Area where the image should be laid out within the current page
//		/// </summary>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// How the image should be aligned within the defined layout area
//		/// </summary>
//		/// <remarks>
//		/// If BestFit is specified, then the image should be scaled to the best possible fit that will preserve the
//		/// aspect ratio of the source image.
//		/// </remarks>
//		public PDFElementAlignment Alignment { get; set; }
//	}


//	public class PDFTextElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.Text; }

//		/// <summary>
//		/// The text that should be rendered as a fixed element in the document.
//		/// </summary>
//		public string Text { get; set; }

//		/// <summary>
//		/// ID of the font to be used when rendering this text element. Must correspond
//		/// with the ID of a font defined in the document model.
//		/// </summary>
//		/// <remarks>
//		/// NOTE: Search for a matching font should be case insensitive.
//		/// </remarks>
//		public string FontID { get; set; }

//		/// <summary>
//		/// Color of the text (default to black)
//		/// </summary>
//		public ARGBColor Color { get; set; } = ARGBColor.Black;

//		/// <summary>
//		/// Area where the text should be laid out within the document
//		/// </summary>
//		/// <remarks>
//		/// The specified area should have enough space for the text that is being printed out,
//		/// however, text should wrap to as many lines as necesary within the area, and no clipping
//		/// should happen even if the text exceeds the available space. 
//		/// </remarks>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// How the text should be aligned within the defined layout area
//		/// </summary>
//		public PDFElementAlignment Alignment { get; set; }

//		/// <summary>
//		/// Indicates if text should be laid out horizontally or rotated 90°/270°
//		/// </summary>
//		/// <remarks>
//		/// When rotated, the layout area will already correspond to the rotated coordinates.
//		/// </remarks>
//		public PDFTextDirection Direction { get; set; }
//	}


//	public enum PDFTextDirection
//	{
//		Normal,
//		Rotated90,
//		Rotated270,
//	}


//	public class PDFBarcodeElement : PDFElement
//	{
//		public override PDFElementType ElementType { get => PDFElementType.Barcode; }

//		/// <summary>
//		/// Barcode type
//		/// </summary>
//		public PDFBarcodeType BarcodeType { get; set; }

//		/// <summary>
//		/// Barcode data. Cannot be null or empty.
//		/// </summary>
//		public string Data { get; set; }

//		/// <summary>
//		/// Area where the barcode should be laid out within the current page
//		/// </summary>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// This is used when printing on dark paper, in that scenario the printer will use white ink
//		/// instead of black, therefore the barcode colors should be inverted (white become black,
//		/// black becomes white).
//		/// </summary>
//		public bool InvertColor { get; set; }
//	}


//	public enum PDFBarcodeType
//	{
//		Code128,
//		QR,
//		DataMatrix
//	}


//	public class PDFLabelPreviewElement
//	{
//		/// <summary>
//		/// Reference to the label preview that should be displayed in this element.
//		/// </summary>
//		public int PreviewID { get; set; }

//		/// <summary>
//		/// Determines which side of the preview should be displayd in this element (can be either front or back). If the requested side was not
//		/// previewed, then an error should be generated.
//		/// </summary>
//		public LabelSide Side { get; set; }

//		/// <summary>
//		/// Area where the referenced preview should be placed within the current page.
//		/// </summary>
//		/// <remarks>
//		/// We will use the actual size of the label to calculate this, and if possible, we will supply an area that
//		/// matches (or is bigger than) the label size. However if the label does not fit the available space, then
//		/// the area might be smaller and ScaleToFit will be set to true. This should rarely happen, but might occur
//		/// for instance when generating a preview document in letter paper size, where the available space might be
//		/// smaller than the label itself.
//		/// 
//		/// If the preview includes a title and or a foot note, asume that the height of each of these elements 
//		/// has already been added to the LayoutArea, such that the label preview generated by nice label, needs to
//		/// be placed below the title.
//		/// </remarks>
//		public PDFArea LayoutArea { get; set; }

//		/// <summary>
//		/// True if the preview should be scaled down to fit the LayoutArea. Note: Scaling only applies if the area is
//		/// smaller than the label size.
//		/// </summary>
//		public bool ScaleToFit { get; set; }

//		/// <summary>
//		/// Text to be displayed on top of the generated preview. Can be null.
//		/// </summary>
//		/// <remarks>
//		/// The Text property of this element might reference fields from the data source.
//		/// 
//		/// For instance if the label is bound to an access file:
//		///		- The text "{VariableData.Barcode}, Units: {OrderDetail.Quantity}", would have to be preprocessed by replacing 
//		///		  {VariableData.Barcode} and {OrderDetail.Quantity} with the respective values extracted from the specified
//		///		  table and field.
//		///		
//		///		- In the other hand, if the label is bound to variables, then data is to be extracted from the json data:
//		///		  The text "{Barcode}, Units: {Quantity}", would have to be preprocessed by replacing the tokens by the
//		///		  actual variable values from the json object that was used to feed the label.
//		/// </remarks>
//		public PDFTextElement Title { get; set; }

//		/// <summary>
//		/// Text to be displayed below the generated preview. Can be null.
//		/// </summary>
//		/// <remarks>Same as with Title</remarks>
//		public PDFTextElement FootNote { get; set; }
//	}


//	public enum LabelRotation
//	{
//		None,
//		Rotated90,
//		Rotated180,
//		Rotated270,
//	}


//	public enum LabelSide
//	{
//		Front,
//		Back,
//		Both
//	}


//	public class PDFFont
//	{
//		/// <summary>
//		/// ID of the font, used to reference this font from other elements. Cannot be null.
//		/// </summary>
//		public string ID { get; set; }

//		/// <summary>
//		/// Font name, cannot be null.
//		/// </summary>
//		public string FontName { get; set; } = "Arial";

//		/// <summary>
//		/// Font size in pts (by standard 1 point equals 1/72 of an inch)
//		/// </summary>
//		public double FontSize { get; set; } = 12;

//		/// <summary>
//		/// Font style
//		/// </summary>
//		public FontStyle FontStyle { get; set; } = FontStyle.Normal;
//	}


//	public enum FontStyle
//	{
//		Normal,
//		Bold,
//		Italic
//	}


//	public class PDFSize
//	{
//		/// <summary>
//		/// Width given in millimeters
//		/// </summary>
//		public double Width;

//		/// <summary>
//		/// Height given in millimeters
//		/// </summary>
//		public double Height;

//		public PDFSize(double w, double h)
//		{
//			Width = w;
//			Height = h;
//		}

//		public PDFSize() { }
//	}


//	public class PDFArea
//	{
//		/// <summary>
//		/// X coordinate in millimeters, measured from the left of the document.
//		/// </summary>
//		public double Left;

//		/// <summary>
//		/// Y coordinate in millimeters, measured from the top of the document.
//		/// </summary>
//		public double Top;

//		/// <summary>
//		/// Width of the area in milimeters
//		/// </summary>
//		public double Width;

//		/// <summary>
//		/// Height of the area in milimeters
//		/// </summary>
//		public double Height;

//		public PDFArea(double left, double top, double width, double height)
//		{
//			Left = left;
//			Top = top;
//			Width = width;
//			Height = height;
//		}

//		public PDFArea() { }
//	}


//	public class ARGBColor
//	{
//		public static readonly ARGBColor None = new ARGBColor(0, 0, 0, 0);
//		public static readonly ARGBColor Black = new ARGBColor(255, 0, 0, 0);
//		public static readonly ARGBColor White = new ARGBColor(255, 255, 255, 255);

//		public int A;
//		public int R;
//		public int G;
//		public int B;

//		public ARGBColor(int a, int r, int g, int b)
//		{
//			A = a;
//			R = r;
//			G = g;
//			B = b;
//		}

//		public ARGBColor() { }
//	}
//}
