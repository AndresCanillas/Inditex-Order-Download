using System;
using System.Collections.Generic;
using System.Net.WebSockets;
using System.Text;
using System.Threading.Tasks;

namespace Service.Contracts
{
	public interface IEventSyncClient: IDisposable
	{
		/// <summary>
		/// Event fired when the client becomes connected. This event is fired when the initial handshake has completed successfully.
		/// </summary>
		event EventHandler Connected;
		/// <summary>
		/// Event fired when the client becomes disconnected. This event is fired when the connection is closed or interrupted regardless of the reason.
		/// </summary>
		event EventHandler Disconnected;
		/// <summary>
		/// Gets or sets the id of this subscriber. Each subscriber must have a unique ID.
		/// </summary>
		string SubscriberID { get; set; }
		/// <summary>
		/// Returns a value indicating if we are connected to the remote endpoint represented by this client.
		/// The client side will automatically attempt reconection if disconnected, so there is no need to call Connect
		/// again or handle disconnection events.
		/// </summary>
		bool IsConnected { get; }
		/// <summary>
		/// Stablishes the shared secret used to start a session with a remote system.
		/// </summary>
		void Configure(IEventSyncStore store, string secret);
		/// <summary>
		/// Subscribes to an event that is generated by a remote system.
		/// NOTES:
		/// 1) You must subscribe to events that are of interest to the local system before stablishing the link between the systems (by calling Connect).
		/// 2) Only events for which you are subscribed will be delivered from the remote system to the local system.
		/// </summary>
		void Subscribe<T>() where T : EQEventInfo;
		/// <summary>
		/// Subscribes to an event that is generated by a remote system and at the same time, setups a type that will be used to handle said event.
		/// </summary>
		void Subscribe<EventType, HandlerType>()
			where EventType : EQEventInfo
			where HandlerType : EQEventHandler<EventType>;
		/// <summary>
		/// Used server side to accept an incoming WebSocket connection from a remote client. Accept will be in charge of performing the initial
		/// handshake in order to stablish the connection.
		/// NOTES: Accept and Connect might raise an exception in case the initial handshake fails (for instance if the shared secret does not match).
		/// </summary>
		Task<int> Accept(WebSocket socket, string ip);
		/// <summary>
		/// Used client side to start a connection to a remote server. Connect will be in charge of performing the initial handshake in order to
		/// stablish the connection. Also, the client system (the one initiating the connection by calling Connect) will be responsible of
		/// restablishing the connection in case of a netwrok issue.
		/// </summary>
		/// <param name="url">The url to the server end point.</param>
		void Connect(string url);
	}


	// Once a connection is stablished, the client and the server will send messages to each other. 
	public class EQMessage
	{
		public EQMessageType Type;       // Message type
		public string Payload;                  // Content of the message, senders must make sure this payload is not greater than 20Kb per message.
												// If either side receives a message that is larger than 20Kb, that party will close the connection
												// and log an error message stating that the disconnection was due to a larger message than allowed.
	}


	public enum EQMessageType
	{
		Handshake,
		HandshakeAck,
		Notification,
		NotificationAck,
		Heartbeat,
		HeartbeatAck,
	}


	// Message sent by the client to initiate a connection to the server	
	public class EQHandshake
	{
		public string Token;			// Random bits used to introduce noise
		public string Secret;           // Secret that was pre-shared between client and server, allows to ensure this connection comes from a trusted client.
		public string SubscriberID;		// The id of the subscriber initiating the connection. This is a combination of MachineName+ProcessName and is what identifies this particular instance of the "client" software. This is used to ensure messages generated by the server are delivered to the client.
		public List<EQSubscription> ActiveSubscriptions;  // A list of all active subscriptions (events) the client is interested in receiving from the server. IMPORTANT: The client must setup all the subscriptions it is interested in receiving before connecting to the server.
	}


	// Message sent by the server to the client in response to a Session Handshake
	public class EQHandshakeAck
	{
		public string SubscriberID;		// This is the subscriber ID of the server. Similar to the subscriber id of the client, this is a combination of MachineName+ProcessName, and is used to ensure messages generated by the client are delivered to the server.
		public List<EQSubscription> ActiveSubscriptions; // A list of all active subscriptions (events) the server is interested in receiving from the client. IMPORTANT: The server must setup all the subscriptions it is interested in receiving before starting the listener and accept connections (at Startup).
	}


	public class EQSubscription
	{
		public string EventName;

		public EQSubscription() { }

		public EQSubscription(string eventname)
		{
			EventName = eventname;
		}

		public override string ToString()
		{
			return EventName;
		}
	}


	public class EQNotification
	{
		public int ID;
		public string EventName;
		public string EventData;
		public DateTime Date;
		public int RetryCount;

		public EQNotification(int id, string eventName, string eventData, DateTime date, int retryCount)
		{
			ID = id;
			EventName = eventName;
			EventData = eventData;
			Date = date;
			RetryCount = retryCount;
		}
	}


	public class EQNotificationAck
	{
		public int ID;
	}


	public class EQEventHandlerResult
	{
		public static readonly EQEventHandlerResult OK = new EQEventHandlerResult() { Success = true, Delay = TimeSpan.Zero };
		public static readonly EQEventHandlerResult Delay5 = new EQEventHandlerResult() { Success = false, Delay = TimeSpan.FromMinutes(5) };

		/// <summary>
		/// Flag indicating if the event was processed successfully or not. If true, the notification is discarded, otherwise the notification is delayed.
		/// </summary>
		public bool Success { get; set; } = true;
		/// <summary>
		/// Amount of time to delay the notification in case it is not successfully processed.
		/// NOTE: If the event handler generates an exception, or if Success is false and no Delay is specified, the notification is automatically delayed N minutes (time increases depending on how many times the event has failed).
		/// </summary>
		public TimeSpan Delay { get; set; } = TimeSpan.Zero;
	}


	public abstract class EQBaseEventHandler
	{
		// TODO: Make async, will have to return Task<EQEventHanderResult>... Also event delivery should not await for each event to complete, intead will have to keep state around, and check event resolution every few seconds (for as long as there are handlers executing), the idea is to not block APM from delivering other events in case some handler takes long to execute... Still, same type events should be queued up for execution in the same dedicated thread, specially if the handler for said event is taking long to process the events, that way events that are processed quickly will flow fast, and events that take long will not use up all the system resources, but be queued instead.
		public abstract EQEventHandlerResult HandleEvent(object e);
	}

	public abstract class EQEventHandler<T> : EQBaseEventHandler where T: EQEventInfo
	{
		public override EQEventHandlerResult HandleEvent(object e)
		{
			return HandleEvent((T)e);
		}

		public abstract EQEventHandlerResult HandleEvent(T e);
	}
}
