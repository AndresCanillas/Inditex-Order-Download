using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Service.Contracts.WF
{
	interface ITaskRunner<TItem> : IDisposable
		where TItem : WorkItem, new()
	{
		/// <summary>
		/// The id of the workflow this task runner belong to
		/// </summary>
		int WorkflowID { get; }

		/// <summary>
		/// The id of the task this runner is attached to
		/// </summary>
		int TaskID { get; }

		/// <summary>
		/// Name of the task
		/// </summary>
		string TaskName { get; }

		/// <summary>
		/// Type implementing this task executable code
		/// </summary>
		Type TaskType { get; }

		/// <summary>
		/// Gets a reference to the parent runner (tasks are nested within each other's scopes, this property allows to navigate the task hierarchy, which can be seen as the call stack)
		/// </summary>
		ITaskRunner<TItem> Parent { get; }

		/// <summary>
		/// Allows to iterate through all sub tasks
		/// </summary>
		IEnumerable<ITaskRunner<TItem>> Tasks { get; }

		/// <summary>
		/// Called while initializing the workflow runner. The TaskNode represents the task that should be executed by the runner.
		/// </summary>
		Task Initialize(ITaskRunner<TItem> parent, TaskNode<TItem> taskNode);

		/// <summary>
		/// Called after the whole workflows has been initialized to signal that the runner can start executing items normally.
		/// </summary>
		/// <param name="next">A callback that should be invoked when an item is successfully executed in this task. This callback will move the item to the next task in the workflow.</param>
		void Start(Func<ItemData, Task> next);

		/// <summary>
		/// Called to instruct this runner to stop processing and shutdown all its background activities.
		/// </summary>
		void Stop();

		/// <summary>
		/// Blocks the caller up to the specified amount of time or until the task responds to the stop signal.
		/// </summary>
		/// <returns>
		/// Returns a value indicating if the task responded to the stop singal within the specified timeout.
		/// </returns>
		/// <remarks>
		/// Will throw immediatelly if the task has not been requested to stop.
		/// </remarks>
		Task<bool> WaitForStop(TimeSpan timeout);

		/// <summary>
		/// Executes the item in the normal way: by moving the item to this task.
		/// </summary>
		/// <param name="item">Item to execute</param>
		Task MoveItemToTask(ItemData item);

		/// <summary>
		/// Execute the item in the Out Of Flow mode: by creating a snapshot of the item state and executing the task using that snapshot.
		/// While executing in this mode, changes made to the item state will not be preserved.
		/// </summary>
		/// <param name="item">The item to execute in the out of flow mode.</param>
		Task<TaskResult> OutOfFlowExecute(ItemData item);

		/// <summary>
		/// Attempts to get a handler for the given exception.
		/// </summary>
		/// <param name="itemData">The item being processed</param>
		/// <param name="ex">The exception generated by a task while processing the item</param>
		/// <param name="finallyLocked">Flag indicating if a handler can move the item to its finally block or not. If the finally route is locked, it means that another handler already has precedence to move the item to its own finally, and no other handler should attempt to take that path.</param>
		/// <returns>Returns a handler if one was found, null otherwise.</returns>
		ITaskExceptionHandler<TItem> GetExceptionHandler(ItemData itemData, Exception ex, bool finallyLocked);
	}


	interface ITaskExceptionHandler<TItem>
		where TItem : WorkItem, new()
	{
		int TaskID { get; }
		Task HandleException(ItemData itemData, Exception ex);
	}


	/// <summary>
	/// Event used to trigger the completion (or cancellation) of an item within a given workflow
	/// </summary>
	public class WakeWorkflowTaskEvent : EQEventInfo
	{
		public WakeWorkflowTaskEvent() { }

		public WakeWorkflowTaskEvent(int workflowid, int taskid)
		{
			WorkflowID = workflowid;
			TaskID = taskid;
		}

		public int WorkflowID { get; set; }
		public int TaskID { get; set; }
	}


	/// <summary>
	/// Event used to trigger the completion (or cancellation) of an item within a given workflow
	/// </summary>
	public class ItemCompletedEvent: EQEventInfo
    {
        public int WorkflowID { get; set; }
        public long ItemID { get; set; }
        public WorkflowStatus WorkflowStatus { get; set; }
		public DateTime Date { get; set; }
	}


	/// <summary>
	/// Event used to trigger the completion (or cancellation) of an item within a given workflow
	/// </summary>
	public class ItemRejectedEvent : EQEventInfo
	{
		public int WorkflowID { get; set; }
		public long ItemID { get; set; }
		public int TaskID { get; set; }
		public string TaskName { get; set; }
		public string RejectReason { get; set; }
		public DateTime Date { get; set; }
	}

    public class ItemPriorityUpdateEvent : EQEventInfo
    {
        public long WorkflowID { get; set; }
        public long ItemID { get; set; }
        public ItemPriority ItemPriority { get; set; }
    }


    static class TaskRunnerExtensions
	{
		public static ITaskRunner<TItem> FindTaskRunner<TItem>(this ITaskRunner<TItem> runner, int taskid)
			where TItem : WorkItem, new()
		{
			var root = runner.GetRoot();
			foreach (var task in root.Tasks)
			{
				if (task.TaskID == taskid)
					return task;
				if(CheckSubTasksByTaskID(task.Tasks, taskid, out var match))
					return match;
			}
			return null;
		}

		private static bool CheckSubTasksByTaskID<TItem>(IEnumerable<ITaskRunner<TItem>> tasks, int taskid, out ITaskRunner<TItem> match)
			where TItem : WorkItem, new()
		{
			match = null;
			foreach(var task in tasks)
			{
				if (task.TaskID == taskid)
				{
					match = task;
					return true;
				}
				if (CheckSubTasksByTaskID(task.Tasks, taskid, out var match2))
				{
					match = match2;
					return true;
				}
			}
			return false;
		}

		public static ITaskRunner<TItem> FindTaskRunner<TItem>(this ITaskRunner<TItem> runner, Type taskType)
			where TItem : WorkItem, new()
		{
			var root = runner.GetRoot();
			foreach (var task in root.Tasks)
			{
				if (task.TaskType == taskType)
					return task;
				if (CheckSubTasksByTaskType(task.Tasks, taskType, out var match))
					return match;
			}
			return null;
		}

		private static bool CheckSubTasksByTaskType<TItem>(IEnumerable<ITaskRunner<TItem>> tasks, Type taskType, out ITaskRunner<TItem> match)
			where TItem : WorkItem, new()
		{
			match = null;
			foreach (var task in tasks)
			{
				if (task.TaskType == taskType)
				{
					match = task;
					return true;
				}
				if (CheckSubTasksByTaskType(task.Tasks, taskType, out var match2))
				{
					match = match2;
					return true;
				}
			}
			return false;
		}

		public static Stack<ITaskRunner<TItem>> GetStack<TItem>(this ITaskRunner<TItem> runner)
			where TItem : WorkItem, new()
		{
			var result = new Stack<ITaskRunner<TItem>>();
			var current = runner;
			while (current.Parent != null)
			{
				current = current.Parent;
				result.Push(current);
			}
			return result;
		}


		public static ITaskRunner<TItem> GetRoot<TItem>(this ITaskRunner<TItem> runner)
			where TItem : WorkItem, new()
		{
			var current = runner;
			while (current.Parent != null)
			{
				current = current.Parent;
			}
			return current;
		}
	}
}
