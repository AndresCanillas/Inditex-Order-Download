using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Service.Contracts
{
	/// <summary>
	/// This class provides an example of the code that is required to implement an interface in a client proxy.
	/// The objective of this class is to serve as a template to generate MSIL using emit.
	/// Compile the project and then disassemble this class to see the intermediate code that was generated by the C# compiler.
	/// </summary>
	class ClientProxyExample : ClientProxy, ISampleService
	{
		public ClientProxyExample(IScope scope, int contractid)
			: base(scope, contractid)
		{

		}

		private EventHandler<int> theevent;

		public event EventHandler<int> TheEvent
		{
			add
			{
				theevent += value;
				RegisterEvent(12359);
			}
			remove
			{
				UnregisterEvent(12359);
				theevent -= value;
			}
		}


		private EventHandler<StatusData> anotherevent;

		public event EventHandler<StatusData> AnotherEvent
		{
			add
			{
				anotherevent += value;
				RegisterEvent(65987);
			}
			remove
			{
				UnregisterEvent(65987);
				anotherevent -= value;
			}
		}


		public int DoSomething(string data)
		{
			using (var rq = StartRequest(14825, false))
			{
				rq.output.AddString(data);
				rq.SendRequest();
				return rq.input.GetInt32();
			}
		}


		public void SetStatus(StatusData status)
		{
			using (var rq = StartRequest(8974, false))
			{
				rq.output.AddObject(status);
				rq.SendRequest();
			}
		}


		public StatusData GetStatus()
		{
			using (var rq = StartRequest(2187, false))
			{
				rq.SendRequest();
				return rq.input.GetObject<StatusData>();
			}
		}


		public Task AddUserAsync(string user, string password)
		{
			var rq = StartRequest(273678, true);
			rq.output.AddString(user);
			rq.output.AddString(password);
			rq.output.EndMessage();

			return rq.SendVoidRequestAsync();
		}


		public Task<string> DoSomethingAsync(string data)
		{
			var rq = StartRequest(954578, true);
			rq.output.AddString(data);
			rq.output.EndMessage();

			return rq.SendTypedRequestAsync<string>();
		}


		// In order to proccess events we need to override OnReceiveEvent and act acordingly. Use this implementation only when the interface has methods
		public override void OnReceiveEvent(int eventid, ProtocolBuffer buffer)
		{
			switch (eventid)
			{
				case 12359:
					int local1 = buffer.GetInt32();
					if (theevent != null)
						theevent(this, local1);
					break;
				case 65987:
					StatusData local2 = new StatusData();
					local2 = buffer.GetObject<StatusData>();
					if (anotherevent != null)
						anotherevent(this, local2);
					break;
			}
		}
	}
}
