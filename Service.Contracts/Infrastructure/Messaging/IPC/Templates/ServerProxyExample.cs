using Services.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading.Tasks;

namespace Service.Contracts
{
	/// <summary>
	/// This class provides an example of the code that is required to implement a server using MsgServer as base class.
	/// The objective of this class is to serve as a template to generate MSIL using emit.
	/// Compile the project and then disassemble this class to see the intermediate code that was generated by the C# compiler.
	/// </summary>
	class ServerProxyExample : ServerProxy
	{
		public ISampleService service;

		public ServerProxyExample(MsgPeer peer, ILogService log, ISampleService service)
			: base (peer, log)
		{
			this.service = service;
			this.ServiceInterface = service;
		}

		private void service_TheEvent(object sender, int data)
		{
			try
			{
				EventData evt = CreateEvent(56478213, 12359);
				ProtocolBuffer buffer = evt.buffer;
				buffer.AddInt32(data);
				SendEvent(evt);
			}
			catch(Exception ex)
			{
				log.LogException(ex);
			}
		}


		private void service_AnotherEvent(object sender, StatusData e)
		{
			try
			{
				EventData evt = CreateEvent(56478213, 65987);
				ProtocolBuffer buffer = evt.buffer;
				buffer.AddObject(e);
				SendEvent(evt);
			}
			catch (Exception ex)
			{
				log.LogException(ex);
			}
		}


		public override void Start()
		{
			this.service.TheEvent += service_TheEvent;
			this.service.AnotherEvent += service_AnotherEvent;
		}


		public override void Stop()
		{
			this.service.TheEvent -= service_TheEvent;
			this.service.AnotherEvent -= service_AnotherEvent;
		}


		public override void InvokeMethod(int methodID, RequestInfo rq)
		{
			switch (methodID)
			{
				case 14825:
					int loc1 = service.DoSomething(rq.input.GetString());
					rq.output.AddInt32(loc1);
					break;
				case 8974:
					service.SetStatus(rq.input.GetObject<StatusData>());
					rq.output.AddInt32(0);  // we add 0 to the output for void methods
					break;
				case 2187:
					StatusData loc2 = service.GetStatus();
					rq.output.AddObject(loc2);
					break;
				default:
					throw new Exception("Unknown method");
			}
		}


		public override Task InvokeMethodAsync(int methodID, RequestInfo rq)
		{
			switch (methodID)
			{
				case 273678:
					var r1 = new AddUserAsyncRunner_5487541(rq, service);
					return r1.Execute();
				case 954578:
					var r2 = new DoSomethingAsyncRunner_5487541(rq, service);
					return r2.Execute();
				default:
					throw new Exception("Unknown async method");
			}
		}
	}

	// NOTE: using await with asynchronous methods use compiler generated state machines behind the scenes, 
	//       we have to mimic that behavior in our generated code.

	class AddUserAsyncRunner_5487541
	{
		private RequestInfo rq;
		private ISampleService service;
		private Task task;

		public AddUserAsyncRunner_5487541(RequestInfo rq, ISampleService service)
		{
			this.rq = rq;
			this.service = service;
		}

		public Task Execute()
		{
			task = service.AddUserAsync(rq.input.GetString(), rq.input.GetString());
			task.ContinueWith(Complete, TaskContinuationOptions.OnlyOnRanToCompletion);
			return task;
		}

		private void Complete(Task t)
		{
			rq.output.AddInt32(0);   // for methods with no return value we add 0 to the output
			rq.output.EndMessage();
			rq.session.SendMessage(rq);
		}
	}


	class DoSomethingAsyncRunner_5487541
	{
		private RequestInfo rq;
		private ISampleService service;
		private Task<string> task;

		public DoSomethingAsyncRunner_5487541(RequestInfo rq, ISampleService service)
		{
			this.rq = rq;
			this.service = service;
		}

		public Task Execute()
		{
			task = service.DoSomethingAsync(rq.input.GetString());
			task.ContinueWith(Complete, TaskContinuationOptions.OnlyOnRanToCompletion);
			return task;
		}

		private void Complete(Task t)
		{
			rq.output.AddString(task.Result);
			rq.output.EndMessage();
			rq.session.SendMessage(rq);
		}
	}
}
