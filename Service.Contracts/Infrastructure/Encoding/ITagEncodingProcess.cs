using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Text;

namespace Service.Contracts
{
	public interface ITagEncodingProcess
	{
		/// <summary>
		/// Gets a flag indicating if the labels should be setup as serialized (each printed label is unique)
		/// </summary>
		bool IsSerialized { get; }

		/// <summary>
		/// Generates the RFID encoding information required to program a tag using the supplied product data. 
		/// </summary>
		/// <returns>Returns the information required to program an RFID tag</returns>
		/// <remarks>
		/// The variable data of the product is required because there are encoding algorithms that require information from the product. Also, the product data can be used to generate the TrackingBarcode.
		/// </remarks>
		List<TagEncodingInfo> Encode(EncodeRequest request);

		/// <summary>
		/// Generates the barcode required as Header for the "Mesa" encoding process
		/// </summary>
		string EncodeHeader(JObject data, int count, long startingSerial, int tagsPerSheet = 1);

		/// <summary>
		/// Generates the RFID encoding information required to program a tag using the supplied product data. This method does not consume serials from the configured sequence.
		/// </summary>
		/// <param name="data">Variable data of the product, must be a flat representation of the VariableData catalog and all related tables, this flat representation can be generated by calling DyncamicDB.FlattenObject</param>
		/// <returns>Returns the information required to program an RFID tag</returns>
		/// <remarks>
		/// EncodeSample WILL NOT consume serial numbers from the configured serial sequence, and therefore, there is no guaranty that the EPC returned is unique.
		/// </remarks>
		TagEncodingInfo EncodeSample(JObject data);
	}

	public interface IAllocateSerialsProcess : ITagEncodingProcess
	{
		ITagEncodingAlgorithm Algorithm { get; }
	}

	public interface IAllocateEpcsProcess : ITagEncodingProcess
	{
	}
}
