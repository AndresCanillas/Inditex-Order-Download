using Service.Contracts;
using Services.Core;
using System.Collections.Generic;
using System.Linq;
using WebLink.Contracts;
using WebLink.Contracts.Models;

namespace WebLink.Services
{
    public class OrderUpdateService : IOrderUpdateService
    {
        private IFactory factory;
        private IOrderUpdatePropertiesRepository settingsRepo;
        private IProjectRepository projectRepo;
        private IOrderRepository orderRepo;
        private IWizardRepository wzdRepo;
        private IOrderLogRepository orderLog;
        private IOrderActionsService actionsService;
        private ILogService log;

        public OrderUpdateService(
            IFactory factory,
            IOrderUpdatePropertiesRepository settingsRepo,
            IProjectRepository projectRepo,
            IOrderRepository orderRepo,
            IWizardRepository wzdRepo,
            IOrderLogRepository orderLog,
            IOrderActionsService actionsService,
            ILogService log)
        {
            this.factory = factory;
            this.settingsRepo = settingsRepo;
            this.projectRepo = projectRepo;
            this.orderRepo = orderRepo;
            this.wzdRepo = wzdRepo;
            this.orderLog = orderLog;
            this.actionsService = actionsService;
            this.log = log;
        }


        /// <summary>
        /// return update process properties... create one if not exist yet
        /// </summary>
        /// <param name="orderID"></param>
        /// <returns></returns>
        private IOrderUpdateProperties GetProperties(PrintDB ctx, int orderID)
        {
            // check process properties exist for this order or register one and return
            var settings = settingsRepo.GetByOrderID(ctx, orderID);

            if(settings == null)
            {
                var data = settingsRepo.Create();

                data.IsActive = false;
                data.IsRejected = false;
                data.OrderID = orderID;

                settings = settingsRepo.Insert(ctx, data);
            }
            return settings;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="orderID"></param>
        /// <param name="projectID"></param>
        /// <param name="brandID"></param>
        /// <returns>0 OK, -1 wait, -2 rejected</returns>
        public int Execute(int orderGroupID, int orderID, string orderNumber, int projectID, int brandID)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                var newOrderInfo = orderRepo.GetProjectInfo(orderID);

                // by definition, orders added while validation process or cloned not enter in conflict
                if(newOrderInfo.Source == DocumentSource.Validation || newOrderInfo.Source == DocumentSource.Repetition)
                {
                    // order generated by validation process, don't check conflicts
                    return 4;
                }

                // validate order state 
                if(newOrderInfo.OrderStatus != OrderStatus.Received)
                {
                    // order status was changed
                    return -3;
                }

                // create properties for this order
                var props = GetProperties(ctx, orderID);
                var comparerConfig = orderRepo.GetComparerType(ctx, orderID);
                // TODO: move devault values to login inner comparerConfig Class
                var comparerMethod = comparerConfig != null && comparerConfig.ID != 0 && !string.IsNullOrEmpty(comparerConfig.Method.ToString()) ? comparerConfig.Method : ConflictMethod.Default;
                var categorizeArticle = comparerConfig != null ? comparerConfig.CategorizeArticle : false;
                // check project settings to handle order updates
                var projectSettings = projectRepo.GetByID(ctx, projectID, true);
                var sameOrders = GetSameOrders(ctx, orderGroupID, orderID, orderNumber, projectID, comparerMethod, categorizeArticle);
                var newOrder = sameOrders.First(w => w.OrderID == orderID);

                if(newOrder.IsStopped)
                {
                    Accept(ctx, orderID, OrderStatus.Received);
                    return -2; // even will be cancelled and relaunch on continue
                }

                if(newOrder.ProductionType == ProductionType.CustomerLocation &&
                    projectSettings.UpdateType == UpdateHandlerType.AlwaysNew)
                {
                    Accept(ctx, orderID, OrderStatus.ProdReady); // keep status 
                    orderLog.Info(ctx, orderID, $"Order {orderNumber} was received");
                    return 3;
                }

                // AlreadyExist ?
                if(sameOrders.Count(w => w.OrderID != orderID) < 1)
                {
                    Accept(ctx, orderID);
                    orderLog.Info(ctx, orderID, $"Order {orderNumber} was received");
                    return 0;
                }

                var pendingOrders = sameOrders.Where(w => w.IsActive.Equals(false)).OrderBy(o => o.OrderCreatedAt).ToList();
                var currentOrder = sameOrders.First(w => w.IsActive.Equals(true) || w.OrderID.Equals(orderID));
                var currentValidator = wzdRepo.GetByOrder(ctx, currentOrder.OrderID);

                if(pendingOrders.Count() >= 1
                    && pendingOrders.First().OrderID != orderID
                    )
                {
                    Reject(ctx, pendingOrders.First().OrderID); // reject older
                    orderLog.Info(ctx, orderID, "pending order - auto replace for the newest");
                    return -4; // cancel event - conflict order is replaces by the new
                }


                //if (projectSettings.AllowOrderChangesAfterValidation)
                if(projectSettings.UpdateType == UpdateHandlerType.NotAllow)
                {
                    Reject(ctx, orderID);
                    orderLog.Info(ctx, orderID, " updates not allow for this project");
                    return -2;
                }

                // TODO: currentOrder is validated, Are updates allowed ?
                // check if are differences,  are the same -> reject update, log reason

                bool areEqual = CompareOrders(ctx, orderID, currentOrder); // compare logic

                if(areEqual == true)
                {
                    Reject(ctx, orderID);
                    orderLog.Info(ctx, orderID, "update was rejected, the same file was previously received");
                    return -3;
                }
                else if(projectSettings.UpdateType == UpdateHandlerType.Auto)
                {

                    Update(ctx, comparerMethod, orderID, currentOrder.OrderID);

                    orderLog.Info(ctx, orderID, "Updated - Auto update allowed");
                    return 1;
                }
                else
                {
                    // no handle conflicts, accept order if article conflicts is disabled
                    if(newOrder.ArticleHasEnableConflicts == false)
                    {
                        Accept(ctx, newOrder.OrderID);
                        return 1;
                    }


                    /*
                     TODO: IDEA - require testing, REPLACE ORDER without validator
                    // si el pedido no tiene validator o la validcion no ha comenzado se reemplaza, ya que no se puede resolver conflicto con ordenes que no han avanzado hasta este punto
                    if(currentValidator == null || (currentValidator != null && currentValidator.Progress <= 0))
                     */

                    // los pedidos deben tener validator to allow automatic replace
                    if(currentValidator != null && currentValidator.Progress <= 0)
                    {
                        Update(ctx, comparerMethod, orderID, currentOrder.OrderID);
                        orderLog.Info(ctx, orderID, $"Updated - the current validation for [{currentOrder.OrderID}] has not progress");
                        orderLog.Info(ctx, currentOrder.OrderID, $"Rejected - this order was replaced with a new version [{orderID}]");
                        return 1;
                    }
                    else// if (projectSettings.UpdateType == UpdateHandlerType.RequestConfirm)
                    {
                        MarkConflict(ctx, comparerMethod, currentOrder.OrderID);
                        orderLog.Warn(ctx, orderID, $"Conflict Found - the current order ({currentOrder.OrderID}) is marked \"In Conflict\"");
                        return -4;
                    }
                }
            }
        }


        private IEnumerable<OrderToUpdateDTO> GetSameOrders(PrintDB ctx, int orderGroupID, int orderID, string orderNumber, int projectID, ConflictMethod method, bool categorizeArticle)
        {
            var orderInfo = orderRepo.GetProjectInfo(ctx, orderID);
            return orderRepo.GetOrdersToUpdate(ctx, orderGroupID, orderID, orderNumber, projectID, method, categorizeArticle, orderInfo.LocationID, orderInfo.ProviderRecordID).ToList();
        }


        private bool CompareOrders(PrintDB ctx, int currentOrderID, OrderToUpdateDTO prevOrder)
        {
            var compareResult = orderRepo.Compare(ctx, currentOrderID, prevOrder.OrderID, false, prevOrder.LabelID ?? 0);
            //var conflictedOrder = orderRepo.GetConflictedOrderFor(currentOrderID);

            var totalNew = compareResult.NewDataUpdates.All(y => y.Count.Equals(0));
            var totalPrev = compareResult.PrevDataUpdates.All(y => y.Count.Equals(0));

            return totalPrev == true && totalNew == true;
            //return compareResult.NewDataUpdates.SequenceEqual(compareResult.PrevDataUpdates);
        }


        /// <summary>
        /// New order is accepted
        /// </summary>
        /// <param name="orderID"></param>
        public void Accept(int orderID, OrderStatus newStatus = OrderStatus.Processed)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                Accept(ctx, orderID, newStatus);
            }
        }


        public void Accept(PrintDB ctx, int orderID, OrderStatus newStatus = OrderStatus.Processed)
        {
            var properties = GetProperties(ctx, orderID);

            properties.IsActive = true;
            properties.IsRejected = false;

            settingsRepo.Update(ctx, properties);
            orderRepo.ChangeStatus(ctx, orderID, newStatus);
        }

        //public void Update(ConflictMethod conflictMethod, int aceptedOrder, params int[] rejecteOrder)
        //{
        //    if (conflictMethod != ConflictMethod.Data)
        //    {
        //        Update(aceptedOrder, rejecteOrder.First());
        //    }
        //}

        public void Update(ConflictMethod conflictMethod, int acceptedOrderID, params int[] rejetedOrderIds)
        {
            Update(conflictMethod, acceptedOrderID, rejetedOrderIds.ToList());
        }

        public void Update(ConflictMethod conflictMethod, int acceptedOrderID, IEnumerable<int> rejetedOrderIds)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                Update(ctx, conflictMethod, acceptedOrderID, rejetedOrderIds);
            }
        }

        public void Update(PrintDB ctx, ConflictMethod conflictMethod, int acceptedOrderID, params int[] rejetedOrderIds)
        {
            Update(ctx, conflictMethod, acceptedOrderID, rejetedOrderIds.ToList());
        }

        public void Update(PrintDB ctx, ConflictMethod conflictMethod, int acceptedOrderID, IEnumerable<int> rejetedOrderIds)
        {
            Accept(ctx, acceptedOrderID);

            if(conflictMethod == ConflictMethod.SharedData)
            {
                rejetedOrderIds.ToList().ForEach(id => RejectBySharedData(ctx, id));
            }
            else
            {
                rejetedOrderIds.ToList().ForEach(id => Reject(ctx, id));
            }

        }

        public void Reject(IEnumerable<int> orderIDs)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                orderIDs.ToList().ForEach(id => Reject(ctx, id));
            }
        }

        public void Reject(PrintDB ctx, IEnumerable<int> orderIDs)
        {
            orderIDs.ToList().ForEach(id => Reject(ctx, id));
        }

        public void Reject(params int[] orderID)
        {
            Reject(orderID.ToList());
        }

        public void Reject(PrintDB ctx, params int[] orderID)
        {
            Reject(ctx, orderID.ToList());
        }


        public void Reject(PrintDB ctx, int orderID)
        {
            var properties = GetProperties(ctx, orderID);

            properties.IsActive = false;
            properties.IsRejected = true;

            settingsRepo.Update(ctx, properties);
            orderRepo.ChangeStatus(ctx, orderID, OrderStatus.Cancelled);
        }

        public void RejectBySharedData(int orderID)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                RejectBySharedData(ctx, orderID);
            }
        }

        public void RejectBySharedData(PrintDB ctx, int orderID)
        {
            var sharedData = orderRepo.GetOrderWithSharedData(orderID).ToList();

            sharedData.ForEach(e =>
            {
                Reject(ctx, e.ID);
            });
        }

        public void MarkConflict(ConflictMethod conflictMethod, int orderID)
        {
            using(var ctx = factory.GetInstance<PrintDB>())
            {
                MarkConflict(ctx, conflictMethod, orderID);
            }
        }

        public void MarkConflict(PrintDB ctx, ConflictMethod conflictMethod, int orderID)
        {
            var order = orderRepo.GetByID(ctx, orderID);

            order.IsInConflict = true;
            orderRepo.Update(ctx, order);

            // stop order signal
            actionsService.StopOrder(ctx, orderID);

            if(conflictMethod == ConflictMethod.SharedData)
            {
                // mark order with the same data in conflict
                var ordersWithSharedData = orderRepo.SetConflictStatusByShareData(true, orderID);

                ordersWithSharedData.ToList().ForEach(ord => actionsService.StopOrder(ctx, ord.ID));
            }

        }

        /*
		public void MarkConflict(int orderID)
		{
			using (var ctx = factory.GetInstance<PrintDB>())
			{
				MarkConflict(ctx, orderID);
			}
		}


		public void MarkConflict(PrintDB ctx, int orderID)
		{
			var order = orderRepo.GetByID(ctx, orderID);

			order.IsInConflict = true;
			orderRepo.Update(ctx, order);

			// stop order signal
			actionsService.StopOrder(ctx, orderID);
		}
        */
    }
}
