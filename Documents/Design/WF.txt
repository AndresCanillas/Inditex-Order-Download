


	// WorkItem defines a bunch of properties that are common to all typed items, inheriting classes then can add any additional information that makes sense for the work at hand

	public class OrderItem : WorkItem    
	{
		public int CompanyID;
		public int BrandID;
		public int ProjectID;
		public int OrderID;
	}

	// IMPORTANT: Avoid defining methods on typed WorkItems, it is not a good practice to add behaviors (methods) to data contracts in general.
	//            You can however include calculated properties (which might evaluate several data elements whithin the item to produce a result).




	// Note: This ensures ILocalization service can translate the name of the task to all supported languages: g["Send order received email"]   
	[TaskInfo(
		Name = "Send order received email",		// Display name for this task
		CanRunOutOfFlow = true)]				// Indicates if this task can run in isolation on demand without causing side effects. Be careful with this, the default value should be false unless you know this task can be run on demand regardless of the status of the item. Usually only Tasks that are idempotent and make no changes to the item information qualify to have this option enabled.
	public class SendOrderReceivedEmail : WorkflowTask<OrderItem>
	{
		public SendOrderReceivedEmail( 
			// inject any dependencies here
		)
		{
		}

		public override Task<TaskResult> Execute(OrderItem item)
		{
			// Execute this task process on the received order item
		}
	}



	// Example workflow definition...


	var wf = apm.AddWorkflow<OrderItem>("Order Processing Workflow")
		.Insert<OrderReceivedEvent, CreateOrderItem>()
		.Execute<SendOrderReceivedEmail>()
		.Execute<CreateArticlePreviews>()
		.Execute<OrderExistVerifier>()				// Note: Tasks that are followed by a Route() call MUST return a route code in the result to specify which branch should execute next. Not doing so, or specifying a branch code that is not defined in the workflow will cause the item to be put in the rejected state in the current task, and processing will not continue.
		.Route()
		    .Branch("OK")
				.Execute<OrderValidator>()
				.Route()
					.Branch("VALIDATED")
						.Execute<SendOrderValidatedEmail>()
						.If(item => !item.BillingCompleted)
							.ExecuteWorkflow("Order Billing Workflow")	// Branches execution to the specified workflow. While the invoked workflow runs, the item will remain in its current task, but in the 
																		// Waiting state. The item will resume execution in this workflow once the invoked workflow completes. If the item is cancelled in the
																		// invoked workflow, then the item will also be cancelled in this workflow and viceversa. IMPORTANT: The invoked workflow must define
																		// the same type of item or use a common base type, otherwise an exception will be thrown when the automated process manager is started;
																		// like wise, an exception will be thrown if the specified workflow has not been defined with a call to AddWorkflow.
																		//
																		// To execute a different workflow without suspending the processing of the item in this workflow, use ParallelExecuteWorkflow.
																		// Notice however that if the current workflow depends on data generated by the invoked workflow running in Parallel, execution
																		// will likely cause an error, ParallelExecuteWorkflow should be used only when the two workflows execute unrelated tasks that do not
																		// depend on each other. 
						.ElseIf(item => condition2)
							.Execute<TaskX>()
						.ElseIf(item => condition3)
							.Try()							// Catch branches can be used to specify Tasks that should execute when an exception is thrown while executing another task in the workflow, having catch
								.Execute<TaskY>()			// branches also means that the item will not stop processing, instead any catched error will be considered as "dealt with" in the corresponding catch branch,
							.Catch<ExceptionType>()			// and then the item will continue its normal processing through the rest of the workflow.
								.Execute<TaskC>()
							.Catch()					
								.Execute<TaskD>()
							.End()
						.Else()
							.Execute<TaskZ>()
								.OnException<Handler1>()				// OnException allows to register an exception handler for the preceding task. Multiple handlers can be setup this way
								.OnExcetion<ExceptionType, Handler2>()	// and is also possible to indicate which type of exception each handler will respond to. Exception Handlers do not take part
																		// in the workflow (they are not workflow tasks). The item will remains in its current task in the Delayed or Rejected state
																		// (depending on the item RetryCount).
																		//
																		// IMPORTANT:
																		//   > The task has to let exceptions flow up the call stack (not handle them internally) in order for exception
																		//     handlers to be invoked.
																		//
																		//   > Handlers are not retried if they throw an exception, but if a handler generates an exception, that exception
																		//     will be automatically added to the item history for tracking purposes.
																		//
																		//   > In general, handlers will not affect the state of the item, even if they throw, and handlers cannot directly
																		//	   affect how the workflow will proceed with the item.
																		//
																		// OnException can be used to perform additional operations on the system in response to errors in critical tasks.
																		// For example, a handler might try to send a message or some sort of notification in case of error, or perform 
																		// some changes in the state of some records in the database in response to the error.
																		//
																		// It is not recomended that exception handlers use the workflow API to try to change the item state or move it to a
																		// different task, as that can easily lead to a thigly coupled workflow that is harder to mantain and understand.
																		// If you need to handle errors as part of the normal flow of execution of the items, then use Try/Catch/Finally
																		// methods instead of OnException.

						.End()
						.Execute<CreateOrderDocuments>()
						.Execute<SendOrderReadyForProductionEmail>()
						.Execute<CreatePrintPackage>()
							.Raise<PrintPackageReadyEvent>()		// Raise will setup an event that will be generated once the preceding task sucessfully completes an item. Multiple events can be setup
																	// for any given task, all the registered events will be raised for each completed item. NOTE:Events are not generated if the item is
																	// Delayed, Rejected or Cancelled. NOTICE that Raise is not a workflow task, but rather, a process that will be performed after the
																	// preceding task completes executing an item. IMPORTANT: The specified event must have a public constructor that takes the item as
																	// argument, otherwise an exception will be thrown and the item will be put in the rejected.

					.DefaultBranch()								// The Route() method can accept a DefaultBranch(), if a default branch is specified, then the task preceding the Route method call
																	// is allowed to complete without providing a route code. Notice, however, that route code that has not been defined as a branch in
																	// the workflow will still cause an error even if a DefaultBranch has been setup.

						.Wait<OrderValidatedEvent, WaitingForValidation>((e, item) => item.OrderID == e.OrderID)

											// Wait will have the WorkItem sit in the Task (WaitingForValidation) in the Waiting state until a corresponding event
											// is received (in this example we wait for OrderValidatedEvent). Wait requires a predicate that will be evaluated to determine
											// if the received event corresponds to the item being processed.
											// IMPORTANT: The Execute method will not run until an event of the specified type that meets the given predicate is received.

						.MoveToBranch("VALIDATED")			// Moves the item to the specified brach. IMPORTANT: The specified branch must be within the scope of the preceding Route method, 
															// also the specified branch cannot be the branch that is currently executing. Finally, if you want to move the item to the default
															// branch (asuming one has been defined), then use the MoveToDefaultBranch method instead.
				.End()

			.Branch("DUPLICATED")
				.CancelItem()						// CancelItem causes the item to be cancelled, stopping any further processing on it.

		    .Branch("CONFLICT")
				// NOTE: Order is put in conflict and then we wait for a resolution...
				.Execute<PutOrderInClonflict>()
				.Execute<SendOrderConflictEmail>()
				.Wait<WaitingForConflictResolution, ConflicResolvedEvent>((item, e) => item.OrderID == e.OrderID)

				// Unconditionally moves the item to the specified task
				.MoveToTask<OrderExistVerifier>()		
		.End()
		.ExecuteWorkflow("Production Control Workflow")
	.End();  // NOTE: At this point the item is considered fully complete (it has gone through the entire workflow). The item will automatically be updated as completed by the workflow manager.
	


	Additional notes on workflow definition.

	The previous example is complex on porpouse, the general recomendation would be to break down complex workflows into smaller workflows. And then use ExecuteWorkflow instead of Execute<Task>
	to reduce the complexity of a workflow definition. A hint of this was given when we invoke the "Order Billing Workflow" and then the "Production Control Workflow". We could have wrapped
	other large sections of the preceding example into separate workflows to reduce the overall complexity of the workflow definition.



Workflow API

This API allows to freely manipulate items that are being processed in the workflow (with certain limitations). 
It also allows to retrieve information about the workflows that were defined, their tasks, and their definition.
This information can be used to create an administrative UI in your front end.


var workflows = apm.GetWorkflows();							// Retrieves an enumeration of all defined workflows

var wf = apm.GetWorkflow("Order Processing Workflow");		// Retrieves an specific workflow by name


IWorkflow object
	Properties:
		Name

	Workflow methods:
		GetDefinition()			- Retrieves a hierarchical data structure that can be used to represent the workflow on screen in a way that is more representative of the workflow logic
		GetTasks()				- Retrieves a simple list of all task defined in the workflow (with no additional hierarchical information)
		GetTask(name)			- Retrieves the task with the specified name
		GetTask<TaskType>()		- Retrieves the task with the specified type
		FindItem(id)			- Searches for the specified item by id, no matter in which task (or status) it might be in. NOTE: ids are assigned internally by the workflow manager when an item is created.
		FindItem(name)			- Searches for the specified item by name, no matter in which task (or status) it might be in. NOTE: usually the item name is an easy to understand value for the user, for instance, the a reference code given to an order. The only limitation is that the item Name cannot be longer than 20 characters.
		FindItem(keywords)		- Searches for the specified item by its keywords, no matter in which task (or status) it might be in. NOTE: usually the keywords field can be used to ease searching of items, it can include any number of words (separated by comma or space). For instance it can include the client name, the brand name, the project name, the order number assigned by the client, etc. Assigning keywords will ease finding items later. Internally the system uses a full text search index to locate records using keywords. The keywords field cannot be larger than 255 characters.
		FindItem(filter)		- Searches for the specified item by using a combination of multiple filters. Filter can include any of the following: item id, item name, keywords, task name & item status. You can use any combinations of these filters to limit the results of the search. If you dont want to filter by an specific property, simply leave that property as null, otherwise specify a value.

IWorkflowTask object
	Properties:
		Name					- Task name
		CanRunOutOfFlow			- Indicates if this task can be invoked on an directly on an item, even if that item is not currently in this task.
		Routes					- Provides a list of all valid route codes defined for this task.

	Methods: 
		GetItems()				- Retrieves a list of all the items that are in this task. NOTE: Items are constantly trying to execute in this task, so take into account the the data returned by all these "Get" methods can quickly become stale.
		GetItems(state)			- Retrieves a list of all the items that are in this task with the given state. NOTE: Items are constantly trying to execute in this task, so take into account the the data returned by all these "Get" methods can quickly become stale.
		GetItem(itemid)			- Retrieves an item from this task by its id, or null if the item cannot be found. NOTE: Items are constantly trying to execute in this task, so an item that is retrieved with this method might actually move to another task between this call and subsecuent calls to the task/item objects.
		GetCounters()			- Returns a data structure with counters that represent the number of items in this task and their different states: TotalItems, ReadyItems, DelayedItems, WaitingItem & RejectedItems. This data is volatile (meaning it can change under the water without you knowing), it is not automatically updated, you should not attempt to get the counters of a task too frequently as that can cause innecesary overhead, the recomended time lapse between refreshes is 5 seconds as a minimum.
		Task Execute(itemid)   	- Attempts execution of the specified item. Can only be called if the specified item is in this particular task, or if the CanRunOutOfFlow flag for the task is true.

								  In the first scenario, when the item is in this task, calling Execute will simply shotcuts the delay time of the item to 0, so the item executes as soon as possible. In this case the call to Execute will not
								  generate any exception, you can await the task returned by Execute if you need to perform additional processing after the item finishes execution, or simply ignore the task to let it run in background, unatended.
								  
								  Note: Calling Execute on an item that is not currently on this task, when the task is not marked as CanExecuteOutOfFlow, will produce an InvalidOperationException. Also take into account that the Workflow API
								  works on snapshots taken out of the system, this means that even if you try to validate that the item is in this task before calling Execute, by the time Execute is actually called, the item might have already
								  moved to another task, causing the exception any way, so keep that little "multi-threading" detail in mind at all times.

								  In the second scenario (the task CanRunOutOfFlow flag is true and the item is not currently on this task), the task will execute on the item regardless of where the item is, or what state it has so long as the item is still Active (an active item is one that is still in the InFlow state, i.e., not completed nor cancelled).
								  Notice that in this second scenario, the item is not moved from its current task, also it is important to note that tasks that are marked as CanRunOutOfFlow have two ways in which they can execute:
								  
								    > The normal InFlow execution (which is when an item is actually in the task and is simply executing normally), and
									> The OutOfFlow execution, which is when execution is forced when the item is not currently on this task. 
									
								The ExecutionMode property found in the typed work item can be used to know if the task is executing in the InFlow mode or the OutOfFlow mode. This might be important because when 
								executing in OutOfFlow mode, the task will execute on a fresh snapshot of the item, not the real item itself. This means that:

									- The item might be executing in another task at the same time, but more importantly,
									- That when executing in OutOfFlow mode, it will not be possible to make state changes on the item (update any of its properties) or try to route it to a different task.
									
								Any attempt to update the item state will cause an exception, and the process will be aborted. Notice however that since we are executing in OutOfFlow mode, that exception will not have any
								side effect on the real item, besides a record being added to the item history to indicate the failure of the OutOfFlow execution. 
								
								Also, any exception generated while executing OutOfFlow will be marshalled back to the process that called Execute in the first place (well assuming you care to check the task result), so be
								ready to handle exceptions thrown by the task when directly calling OutOfFlow tasks.

								Final notes on Execute

								In general it is not expected that the program invokes Execute like this all the time, the workflow manager will be the one responsible of making sure tasks execute as fast as possible an move through the workflow.
								This Execute method is provided only for the rare cases in which a user wants to force inmediate execution of an item (that might be in the delayed or rejected state for instance), or when we want
								to force the OutOfFlow execution of a task. Typical examples of taks that can be requested to execute OutOfFlow are: Tasks that generate documents, previews or send email notificaions.


IWorkItem object
	Properties:
		ID				// Read-only. String of up to 38 character that is also unique. No other item is allowed to have the same ID, this is regardless of the fact that the items might be of different base types. Should be provided when the item is created and cannot be changed afterwards.
		Name			// Read-only. String with a user friendly description of the item (could be for instance the order number given by the client). Its maximum size is 50 characters. Should be provided when the item is created and cannot be changed afterwards.
		Keywords		// Read/write, is a string that can be used to ease item searching. The item ID, Name and Keywords can be used to quickly search for an item in the system.
		ItemPriority	// Read/write. Priority of the item, higher priority items execute before items with other priorities.
		WorkflowStatus	// Read-only. A value indicating if the item is active (in flow), or has been completed/cancelled.
		CurrentTask		// Read-only. Read-only the name of the task the item is currently at*. If the item is no longer active, then this property will be set to the name of the last task before the item was completed or cancelled.
		ItemStatus		// Read-only. The general status of the item* within the current task. If the item is no longer active, then this property will reflect the state the item had when it was completed or cancelled.
		StatusReason	// Read-only. For certain status it is required that a reason for placing the item in that status is given, that reason can be seen in this property.
		RouteCode		// Read-only. The last route code assigned to the item
		RetryCount		// Read-only. How many times the item has been retried on the current task.
		DelayedUntil	// Read/write. The date at which this item will be retried. Can be DateTime.MaxValue if the item is in the Rejected or Waiting states.
		TaskDate		// Read-only. The date in which the item was registered in the current task. If the item is no longer active, this will reflect the date in which the item was completed or cancelled.

	Methods:
		item.GetHistory()	 - Retrieves the log of everything that has been done to the item in question through its life in the workflow
		item.Delay(reason, time) - Changes the status of the item to Delayed, and sets the DelayedUnitl field using the specified time span, it also updates the StatusReason field. NOTE: Reason cannot be null or empty, the time span cannot be negative or longer than 48 hours.
		item.Ready()		 - Changes the status of the item to Ready so that it is scheduled for execution as soon as possible. Can be used for instance to manually retry a Rejected item.
		item.Reject(reason)	 - Changes the status of the item to Rejected, it also updates the StatusReason field. NOTE: Reason cannot be null or empty.
		item.Wake(event)	 - Wakes an item currently in the waiting state. The data of the event that would wake the item needs to be supplied in the call. Wake will throw an error if the item is in the waiting state due to having invoked a subworflow. In that case, you should go to the subworkflow to try to determine what might be causing the item to not be completed in that other workflow instead of calling Wake.
		item.Move<T>()		 - Moves the item to the specified task within the workflow, the item will be in the ready status. If the item is out of the workflow (complete/cancelled), the item is also reactivated.
		item.Move<T>(status) - Moves the item to the specified task within the workflow, the item will be put in the specified status. If the item is out of the workflow (complete/cancelled), the item is also reactivated. NOTE: When specifying an item status, the status Waiting is valid only if the target task is a WaitingTask or a call to a subworkflow.
		item.Cancel()		 - Moves the item out of the workflow to the cancelled state. Use when you no longer want this item to continue its normal processing.
		item.Complete()		 - Moves the item out of the workflow to the ForcedComplete state. Use when you want the item to be marked as completed, regardless of in which task the item might be. 
		item.Activate()		 - Returns the item to the state it had before it was forced out of the workflow by Complete o Cancel

		IMPORTANT:
		- The item state is not lost when Cancel or Complete are called.
		- Calling Activate will return the item to the task it was and with the state it had before Cancel or Complete were called.
		- Activate will not have any effect on items that completed normally (by reaching the end of the workflow). For such cases you have to use the Move method instead of the Activate method.
		- Activating an item that was forced to complete or was cancelled, will update the item in all the workflows the item was active when it was forced out of the workflow (reactivating the whole workflow call stack).
		- Methods that change the status of the item or move the item to a different task will throw an InvalidOperationException if the item state has been updated since the last time the API took its snapshot, or if the item is currently scheduled for execution (in the Ready state).
		- The Move method will throw InvalidOperationException if the item is in the Waiting state due to a call to a subworkflow.
		    

* For the API objects, many of the item properties are volatile. This means that the values are snapshots taken at the time the query was executed, but do not necesarily reflect the current state of the item. This is because the items will
keep executing and moving from task to task in background all the time.


NOTE: There will be two versions of the item objects:
	1) Generic Items (IWorkItem), those are items as you get them through the Workflow API, those objects are snapshoted, meaning that the item state and displayed values can change without prior warning, also,
	   they offer a different set of operations than the other item version.

	2) Typed Items (like OrderItem for instace), those are items as you get them inside the workflow tasks, those objects inherit from the base class WorkItem and offer a different set of operations than the
	   API version (IWorkItem). The advantage here is that the item object you get while executing a task in not snapshoted, that is, the item status and its properties cannot change out of the blue, as it is
	   guarranted that no other thread can change the item state while it is being actively executing within a task. Also, the item will include all the information (properties) defined by the typed item
	   which can include much more than just the base properties.

	In general it is not advised to try to use the workflow API from within a task to try and manipulate the item that is being processed; in fact you will not be able to do so, as the item will be locked while
	actively executing inside a task. Instead you can use workflow definition methods (such as Route, Branch, MoveToTask or MoveToBranch) to perform actions that are not directly available in the typed item.




Workflow Execution


























































