


Order Previews
----------------------------------------------------------
An initial order preview is generated as soon as an order is proccessed. Additional previews can be requested manually at a
later time by users, for instance after having made changes to product data.



Business Logic
----------------------------------------------------

Orders uploaded to the system are not automatically processed (sent to billing for instance), instead they remain in the
received status unless some process (either automated or manual) picks up the orders and continues the processing.

What happends to an order after it has been received depends on the business logic programmed in the plugins that
have been setup as part of a project.

In general, plugins respond to specific system events. In this version of the system we will have the following events:

Project Level:

	For all the following events, the information of the company, brand, project, the order and order detail is included as
	part of the notification. User defined fields found in the Order and OrderDetail tables can be accessed using .GetValue<T>
	Information from any other catalog defined in the project can be accessed through the Dynamic Data API.

	Additional information might also be included depending on the event. For instance, for OrderCancelled event, an object
	containing information as to why the order was cancelled and when is supplied too. Or For OrderSent, a carrier name and
	guide number is supplied as well.


- OrderReceived		Event raised after an order has been uploaded to the system. At this point we only have a file that
			is awaiting to be processed.

- OrderProcessed	Event raised after an order has been incorpodated into the system (uploaded file has been processed and
			all records created).

- BeforeOrderApproved	Event raised before an order is approved and sent to production. This event can prevent the order from
			being sent to production based on rules and validations.

- OrderApproved		Event raised after an order has been approved for production (when the order status is changed to Approved
			by any process).

- OrderInProduction	Event raised when an order begins printing (when the order status is changed to InProduction
			by any process).

- OrderDeliveryPrep	Event raised when an order has been printed in its enterity and is ready to be sent to the delivery address (when
			the order status is changed to DeliveryPrep by any process).

- OrderSent		Event raised when an order has been sent to its delivery address (picked up by a carrier).

- OrderCompleted	Event raised when an order has been confirmed to have been delivered to the client (when the order status is
			changed to Completed by any process).

- OrderCancelled	Event raised when an order is cancelled (when the order status is changed to Cancelled by any process).

- PreviewGenerated	This is the only event that does not respond to a Status change. This event is raised after a preview for an
			order has been generated by the system. Notice that this can happen multiple times during the life cycle of an order.
			Note: An initial preview starts being generated as soon as an order is received, aditional previews can
			be manually requested later. 



Catalog Level:

	For the following events each event includes the information of the Company, Brand, Project, Catalog, and the data of
	the row being affected.	If the catalog is system defined, the data can be casted to its respective data contract (Product,
	Order, OrderDetail). Otherwise data can only be accessed using GetValue<T>(propertyname), as there is no data contract
	on which to load the record in a strong typed way.

	"Before" events CAN prevent the operation from being executed if there are any rules or validations not passing, this can
	be done either by setting the "Cancel" flag in the event args object to true and providing a reason, or by raising an
	exception (altough the flag/reason method is preferred due to performance).

- BeforeInsert		Event raised before a record in the associated catalog is inserted. 


- AfterInsert		Similar to BeforeInsert, but raises after the data has been inserted in the catalog, therefore it cannot prevent
			data from being inserted.

- BeforeUpdate		Works similar to BeforeInsert, but for updates

- AfterUpdate		Works similar to AfterInsert, but for updates

- BeforeDelete		Works same as BeforeInsert, but for deletes

- AfterDelete		Works same as AfterInsert, but for deletes


A plugin can be created that hooks to any of these events and execute some logic (according to the needs of the project).

By default when a new project is created, it will be configured to use the DefaultProject plugin. This plugin will simply push
order to production as soon as an order is processed and will do little more than that.

If this is not the desired behavior for a project, then you have to remove this plugin from the project folder and create
a new plugin that is specific for this project.

If specific business logic needs to be created for a new project, then the recomendation is to write the plugin in its own
independent project, such that the logic of the plugin can be changed without having to redeploy the entire platform.

The plugin needs to be placed manually in the server in a folder following this naming convention:

"[PlatformDir]\plugins\{companyid}\{brandid}\{projectid}\"

Plugins cannot be uploaded or registered in the platform administrative UI for security reasons (this policy might change later though).
Altough information about the currently setup plugin can be seen in the UI for reference.

If you create a plugin for one project, and this plugin happens to be "reusable" in other projects, you have to manually copy the dll
to the plugins directory that corresponds to each of the projects in which you want to reuse that plugin.

Please be mindfull of how you name these plugins, as the system will load each dll only once, and this is based off the name of the dll.
In other words, to prevent issues, each plugin you create MUST have a unique name.



Data Access API - Server Side
----------------------------------------------------------

Data from the catalogs of a given project can be accessed through a well defined API called "Data Access API".

The main contract for this API is called ICatalogCollection, you can use this object to access catalogs by their name. The collection in turn
returns objects of type ICatalog, you can get information about each specific catalog defined in the project using that object. ICatalog exposes
many operations that return either a single instance of ICatalogRow or an enumerable of ICatalogRow. ICatalogRow represents a single record or
row within the catalog.

Example:
	public void OrderApproved(ProjectEventArgs e)
	{
		ICatalog products = e.Catalogs["Products"];
		ICatalogRow product = products.GetByID(10);
		Console.WriteLine(products.Name);
		Console.WriteLine(product["Barcode"]);
	}

An instance of ICatalogCollection is supplied within the ProjectEventArgs object that is passed to the handlers of all the events 
defined in the plugin model.

Using that, we can get hold of an specific catalog, then with a catalog in hand we can perform the following operations:

int ICatalog.Rows{ get; }			Retrieves the number of rows in the catalog (internally it executes a select count(*) )
IEnumerable<ICatalogRow> ICatalog.Select()	Retrieves all records in the catalog (note: records might get retrieved in chunks instead of all at once)

IEnumerable<ICatalogRow> ICatalog.GetList<T>(select, args)
						Retrieves a list of records that match the specified query and arguments.

ICatalogRow ICatalog.GetByID(int id)		Retrieves the record with the given ID
ICatalogRow ICatalog.Insert()			Inserts a new empty record into the catalog (NOTE this requires that the catalog does not have any NON-empty columns, otherwise youll get an error)
ICatalogRow ICatalog.Insert(string jsonData)	Inserts a new record into the catalog
ICatalogRow ICatalog.Insert<T>(T data)		Inserts a new record into the catalog, T will be reflected uppon to extract the values for each of the columns
ICatalogRow ICatalog.Update(string jsonData)	Updates an existing record within the catalog
ICatalogRow ICatalog.Update<T>(T data)		Updates an existing record within the catalog, T will be reflected uppon to extract the values for each of the columns
void ICatalog.Delete(int id)			Deletes the record with the given ID

Examples:

// Gets all rows from the catalog
var foundItems1 = products.Select();

// Gets all rows whose Barcode is equal to the specified value
var barcode = "1735435345691";
var foundItems2 = products.Select("select * from #TABLE where Barcode = @barcode", barcode);

// Gets all rows whose TXT1 field is equal to the specified value, order by Barcode in descending order
var foundItems3 = products.Select("select * from #TABLE where TXT1 like @txt1 order by Barcode desc", "PACK CAMISETAS");

var product = products.GetByID(10);

var p2 = products.Insert(jsonData);
p2.SetColumn<int>("Size", 10);
products.Update(p2);


ICatalogRow in turn has the following methods and properties:

ICatalog Catalog{ get; }			Gets the catalog to which this row belongs
string this[string columnName] { get; set; }	Gets or Sets the value o the specified column as a string. To get the actual column data as its correct data type use GetColumn<T>/SetColumn<T> instead. The set operation will try to coherce the string into the actual column data type, however this only works for scalar values such as numbers or strings.
T GetColumn<T>(string columnName)		Retrieves the value of a column, you need to know the data type of the column.
void SetColumn<T>(string columnName, T value);	Sets the value of a column, you need to know the data type of the column.

For columns of type Reference, Set, Image or File, you can only use GetColumn<T> and SetColumn<T>, further more, T must be:
	- IRef for reference columns
	- IFile for Image and File columns
	- ISet for set columns

IRef provides a way to get the actual data of the referenced row, and the referenced catalog:
	- ICatalogRow IRef.GetRow()
	- ICatalog IRef.GetCatalog()

IFile has properties and methods to access the file data:
	- int IFile.Length { get; }
	- string IFile.FileName { get; }
	- Stream IFile.GetContentAsStream();
	- byte[] IFile.GetContentAsBytes();
	
ISet has methods to retrieve the set information, the referenced catalog and also to insert/delete into the set itself:
	- IEnumerable<ICatalogRow> ISet.GetList();	Gets all the rows that are part of the set
	- ICatalog ISet.GetCatalog();			Gets the information of the catalog with which this set is composed
	- ICatalogRow ISet.Add(ICatalogRow reference);	Adds a reference to the set
	- ICatalogRow ISet.Add(int id);			Adds a reference to the set using the id of the row to add.
	- void ISet.Remove(ICatalogRow reference);	Removes a reference from the set
	- void ISet.Remove(int id);			Removes a reference from the set using the id of the row to remove.




Data Access API - Client Side
----------------------------------------------------------

This same API is made available client side as a java script library. Access to the catalog is restricted using the current user information
such that users from one company cannot see or interact with catalogs from other companies.




Wizzards
------------------------------------------------

Specific UIs
